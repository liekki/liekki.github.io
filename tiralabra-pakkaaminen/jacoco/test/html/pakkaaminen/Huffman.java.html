<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Huffman.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakkaaminen</a> &gt; <a href="index.source.html" class="el_package">pakkaaminen</a> &gt; <span class="el_source">Huffman.java</span></div><h1>Huffman.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pakkaaminen;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

/**
 * Implements Huffman coding on 8-bit input strings.
 */
public final class Huffman {

    private String input;
    private HashMap&lt;Character, Integer&gt; frequencyTable;
    private MinHeap heap;
    private final HashMap&lt;Character, String&gt; codes;
    private HuffmanTree tree;

    private byte[] dataBytes;
    private byte[] treeBytes;

<span class="fc" id="L32">    public Huffman() {</span>
<span class="fc" id="L33">        this.codes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L34">    }</span>

    public void encodeString(String input) {
<span class="fc" id="L37">        this.input = input;</span>

<span class="fc" id="L39">        this.frequencyTable = generateFrequencyTable(this.input);</span>
<span class="fc" id="L40">        this.heap = generateHuffmanHeap(this.frequencyTable, 256);</span>

<span class="fc" id="L42">        this.tree = generateHuffmanTree(heap);</span>

<span class="fc" id="L44">        generateCodes(this.tree, this.codes, &quot;&quot;);</span>

        try {
<span class="fc" id="L47">            this.dataBytes = encode(this.codes, this.input);</span>
<span class="fc" id="L48">            this.treeBytes = serializeTree(this.tree);</span>

            //System.out.println(&quot;Input size (bytes): &quot; + this.input.length());
            //System.out.println(&quot;Encoded tree size (bytes): &quot; + treeBytes.length);
            //System.out.println(&quot;Encoded data size (bytes): &quot; + dataBytes.length);

            //System.out.println(&quot;codes&quot;);
<span class="fc bfc" id="L55" title="All 2 branches covered.">            for (Map.Entry&lt;Character, String&gt; entry : this.codes.entrySet()) {</span>
<span class="fc" id="L56">                Character key = entry.getKey();</span>
<span class="fc" id="L57">                String value = entry.getValue();</span>
                // ...
                // System.out.println(key + &quot;: &quot; + value);
<span class="fc" id="L60">            }</span>

            //HuffmanTree hydrated = deserialize(treeBytes);
            //System.out.println(&quot;hydrated&quot; + hydrated);
            //System.out.println(&quot;Deserialized input: &quot; + decode(hydrated, dataBytes));
<span class="nc" id="L65">        } catch (Exception e) {</span>
<span class="nc" id="L66">            System.out.println(&quot;Exception &quot; + e);</span>
<span class="fc" id="L67">        }</span>
<span class="fc" id="L68">    }</span>

    /**
     * Writes the encoded data in to a file
     *
     * @param filename file to be written to
     * @throws java.io.IOException
     */
    public void write(String filename) throws java.io.IOException {
<span class="fc" id="L77">        byte[] treeBytesLength = new byte[4];</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L79">            treeBytesLength[i] = (byte) (treeBytes.length &gt;&gt; (3 - i) * 8);</span>
        }
<span class="fc" id="L81">        ByteArrayOutputStream output = new ByteArrayOutputStream();</span>

<span class="fc" id="L83">        output.write(treeBytesLength);</span>
<span class="fc" id="L84">        output.write(treeBytes);</span>
<span class="fc" id="L85">        output.write(dataBytes);</span>

<span class="fc" id="L87">        byte[] bytes = output.toByteArray();</span>

<span class="fc" id="L89">        File.write(filename, bytes);</span>
<span class="fc" id="L90">    }</span>

    /**
     * Reads data from a file and returns the decoded message
     *
     * @param filename file to be read from
     * @return decoded string
     */
    public String read(String filename) {
        try {
<span class="fc" id="L100">            byte[] bytes = File.read(filename);</span>

<span class="fc" id="L102">            byte[] headerBytes = Arrays.copyOfRange(bytes, 0, 4);</span>
<span class="fc" id="L103">            int treeLength = ByteBuffer.wrap(headerBytes).getInt();</span>
<span class="fc" id="L104">            byte[] treeBytes = Arrays.copyOfRange(bytes, 4, 4 + treeLength);</span>
<span class="fc" id="L105">            byte[] dataBytes = Arrays.copyOfRange(bytes, 4 + treeLength, bytes.length);</span>

<span class="fc" id="L107">            this.treeBytes = treeBytes;</span>
<span class="fc" id="L108">            this.dataBytes = dataBytes;</span>

            //System.out.println(&quot;tree length: &quot; + treeLength);
            // System.out.println(&quot;read &quot; + bytes.length + &quot; bytes&quot;);

<span class="fc" id="L113">            HuffmanTree root = deserialize(this.treeBytes);</span>

<span class="fc" id="L115">            return decode(root, this.dataBytes);</span>
<span class="nc" id="L116">        } catch (Exception e) {</span>
<span class="nc" id="L117">            System.out.println(&quot;Exception! &quot; + e.getMessage());</span>
<span class="nc" id="L118">            return null;</span>
        }
    }

    /**
     * Maps each symbol in the input with the corresponding encoding from the
     * encoding table
     *
     * @param codes Huffman encoding table
     * @param input string to be encoded
     * @return encoded bytes
     * @throws java.io.IOException
     */
    public static byte[] encode(HashMap codes, String input) throws java.io.IOException {
<span class="fc" id="L132">        BitSet bits = new BitSet();</span>
        // First byte indicates the length of the last byte 
        // TODO: we actually only need 3 bits here

<span class="fc" id="L136">        int current = 8;</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int i = 0; i &lt; input.length(); i++) {</span>
<span class="fc" id="L139">            String code = (String) codes.get(input.charAt(i));</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (int j = 0; j &lt; code.length(); j++) {</span>
                // System.out.print(code.charAt(j));
<span class="fc bfc" id="L143" title="All 2 branches covered.">                bits.set(j + current, code.charAt(j) == '1');</span>
            }
<span class="fc" id="L145">            current += code.length();</span>
        }
        // System.out.println(&quot;&quot;);

<span class="fc" id="L149">        byte lastByteLength = (byte) ((current - 8) % 8);</span>

<span class="fc" id="L151">        bits.set(0, 4, false);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        bits.set(5, ((lastByteLength &gt;&gt; 2) &amp; 1) == 1);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        bits.set(6, ((lastByteLength &gt;&gt; 1) &amp; 1) == 1);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        bits.set(7, (lastByteLength &amp; 1) == 1);</span>

<span class="fc" id="L156">        return bits.toByteArray();</span>
    }

    /**
     * Decodes given set of bytes into its original form by traversing the tree
     * according to the bits in the data. Starting from the root we pick the
     * left child whenever we read a 0 and the right child when ever we read a 1
     * until we reach a leaf node. That node's symbol is then added to the
     * output and we start again from the root.
     *
     * @param root The Huffman tree for this string
     * @param bytes encoded data
     * @return decoded string
     */
    public static String decode(HuffmanTree root, byte[] bytes) {

<span class="fc" id="L172">        String output = &quot;&quot;;</span>
<span class="fc" id="L173">        HuffmanTree pointer = root;</span>

<span class="fc" id="L175">        int lastByteLength = ((bytes[0] &gt;&gt; 7) &amp; 1) + (2 * ((bytes[0] &gt;&gt; 6) &amp; 1)) + (4 * ((bytes[0] &gt;&gt; 5) &amp; 1));</span>
<span class="fc" id="L176">        int bitsPerByte = 8;</span>

        // System.out.println(&quot;last byte length&quot; + lastByteLength);
        // System.out.print(&quot;Encoded data: &quot;);
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 1; i &lt; bytes.length; i++) {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (i == bytes.length - 1) {</span>
                // For the last byte we dont want to add any extra bits
<span class="fc" id="L183">                bitsPerByte = lastByteLength;</span>
            }
<span class="fc bfc" id="L185" title="All 2 branches covered.">            for (int j = 0; j &lt; bitsPerByte; j++) {</span>
                // System.out.print((bytes[i] &gt;&gt; j) &amp; 1);
<span class="fc bfc" id="L187" title="All 2 branches covered.">                if (((bytes[i] &gt;&gt; j) &amp; 1) == 0) {</span>
<span class="fc" id="L188">                    pointer = pointer.getLeft();</span>
                } else {
<span class="fc" id="L190">                    pointer = pointer.getRight();</span>
                }

<span class="pc bpc" id="L193" title="1 of 4 branches missed.">                if (pointer.getLeft() == null &amp;&amp; pointer.getRight() == null) {</span>
<span class="fc" id="L194">                    output += pointer.getValue();</span>
<span class="fc" id="L195">                    pointer = root;</span>
                }
            }
        }
        // System.out.println(&quot;&quot;);
<span class="fc" id="L200">        return output;</span>
    }

    /**
     * Generates the final Huffman tree by picking two nodes with the smallest
     * weights and adding them back into the heap until the size of the heap is
     * 1.
     *
     * @param heap contains all the nodes as HuffmanTree objects of size 1
     * @return final Huffman tree
     */
    public static HuffmanTree generateHuffmanTree(MinHeap heap) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (heap.getSize() == 1) {</span>
            // Edge case when input consists of only a single character, e.g. &quot;aaaaa&quot; 
<span class="fc" id="L214">            HuffmanTree right = heap.pop();</span>
<span class="fc" id="L215">            HuffmanTree root = new HuffmanTree(right.getWeight(), null, right);</span>
<span class="fc" id="L216">            heap.insert(root);</span>
<span class="fc" id="L217">        } else {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            while (heap.getSize() &gt; 1) {</span>
<span class="fc" id="L219">                HuffmanTree right = heap.pop();</span>
<span class="fc" id="L220">                HuffmanTree left = heap.pop();</span>
<span class="fc" id="L221">                HuffmanTree current = new HuffmanTree(left.getWeight() + right.getWeight(), left, right);</span>
<span class="fc" id="L222">                heap.insert(current);</span>
<span class="fc" id="L223">            }</span>
        }

<span class="fc" id="L226">        HuffmanTree tree = heap.pop();</span>

<span class="fc" id="L228">        return tree;</span>
    }

    /**
     * Generates a frequency table containing the number of occurrences for each
     * individual symbol in the input.
     *
     * @param str input string
     * @return the resulting frequency table as a HashMap
     */
    public static HashMap generateFrequencyTable(String str) {
<span class="fc" id="L239">        HashMap&lt;Character, Integer&gt; table = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (table.containsKey(str.charAt(i))) {</span>
<span class="fc" id="L243">                Integer previous = table.get(str.charAt(i));</span>
<span class="fc" id="L244">                table.put(str.charAt(i), previous + 1);</span>
<span class="fc" id="L245">            } else {</span>
<span class="fc" id="L246">                table.put(str.charAt(i), 1);</span>
            }
        }

<span class="fc" id="L250">        return table;</span>
    }

    /**
     * Initializes the heap by populating it with 1-sized HuffmanTrees.
     *
     * @param table frequency table
     * @param size size of the heap
     * @return generated minimum heap
     */
    public static MinHeap generateHuffmanHeap(HashMap&lt;Character, Integer&gt; table, int size) {
<span class="fc" id="L261">        MinHeap heap = new MinHeap(size);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        for (Map.Entry&lt;Character, Integer&gt; entry : table.entrySet()) {</span>
<span class="fc" id="L263">            Character symbol = entry.getKey();</span>
<span class="fc" id="L264">            Integer weight = entry.getValue();</span>

<span class="fc" id="L266">            HuffmanTree node = new HuffmanTree(symbol, weight);</span>
<span class="fc" id="L267">            heap.insert(node);</span>
<span class="fc" id="L268">        }</span>

<span class="fc" id="L270">        return heap;</span>
    }

    /**
     * Recursive helper that generates the encoding table for each individual
     * symbol in the string and stores them in a HashMap
     *
     * @param tree Huffman tree that encapsulates the coding
     * @param codes a HashMap that will store the codes
     * @param code current coding while traversing the tree
     */
    public static void generateCodes(HuffmanTree tree, HashMap codes, String code) {
<span class="fc bfc" id="L282" title="All 4 branches covered.">        if (tree.getLeft() == null &amp;&amp; tree.getRight() == null) {</span>
<span class="fc" id="L283">            codes.put(tree.getValue(), code);</span>
<span class="fc" id="L284">            return;</span>
        }

<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (tree.getLeft() != null) {</span>
<span class="fc" id="L288">            generateCodes(tree.getLeft(), codes, code + &quot;0&quot;);</span>
        }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (tree.getRight() != null) {</span>
<span class="fc" id="L291">            generateCodes(tree.getRight(), codes, code + &quot;1&quot;);</span>
        }
<span class="fc" id="L293">    }</span>

    /**
     * Serialize a HuffmanTree
     *
     * @param tree The HuffmanTree to be serialized
     * @return serialized byte representation of the tree
     * @throws java.io.IOException
     */
    public static byte[] serializeTree(HuffmanTree tree) throws java.io.IOException {
<span class="fc" id="L303">        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L304">        ObjectOutputStream stream = new ObjectOutputStream(outputStream);</span>

<span class="fc" id="L306">        HuffmanTree.serializeNode(tree, stream);</span>
<span class="fc" id="L307">        stream.close();</span>

<span class="fc" id="L309">        return outputStream.toByteArray();</span>

    }

    /**
     * De-serialize a HuffmanTree
     *
     * @param bytes serialized byte representation of the tree
     * @return de-serialized HuffmanTree
     * @throws java.io.IOException
     */
    public static HuffmanTree deserialize(byte[] bytes) throws java.io.IOException {
<span class="fc" id="L321">        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);</span>
<span class="fc" id="L322">        ObjectInputStream stream = new ObjectInputStream(inputStream);</span>

<span class="fc" id="L324">        return HuffmanTree.deserializeNode(stream);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>